set encoding=utf-8
scriptencoding utf-8

runtime bundle/vim-pathogen/autoload/pathogen.vim

let g:pathogen_disabled = []

if v:version < '800'
  call add(g:pathogen_disabled, 'ale')
else
  call add(g:pathogen_disabled, 'syntastic')
endif

execute pathogen#infect()

if !has('gui') && has('termguicolors')
  let &t_8f = "[38;2;%lu;%lu;%lum"
  let &t_8b = "[48;2;%lu;%lu;%lum"
  set termguicolors
endif

syntax on
filetype plugin indent on

let g:netrw_banner=0
let g:netrw_browse_split=4
let g:netrw_altv=1
let g:netrw_liststyle=3
let g:netrw_list_hide=netrw_gitignore#Hide()
let g:netrw_list_hide.=',\(^\|\s\s\)\zs\.\S\+'

set nu
set modelines=0

set path+=**

set background=dark

let g:vim_monokai_tasty_italic = 1
colorscheme vim-monokai-tasty

let g:airline_theme='monokai_tasty'

set ignorecase smartcase

if executable("rg")
  set grepprg=rg\ --vimgrep\ --no-heading
  set grepformat=%f:%l:%c:%m,%f:%l:%m
endif

set showcmd ruler laststatus=2

set splitright

set history=500
set hidden
set nobackup
set noundofile
set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc

set listchars=trail:.,tab:>-,extends:>,precedes:<,nbsp:Â¬
set list

set backspace=indent,eol,start
set showmatch
set wildmode=full
set wildmenu
set complete-=i

set expandtab
set tabstop=2 shiftwidth=2 softtabstop=2
set foldlevelstart=2

set iskeyword+=-

inoremap <F1> <ESC>
nnoremap <F1> <ESC>
vnoremap <F1> <ESC>

set scrolloff=999
set sidescrolloff=0

set sidescroll=1

let g:ruby_heredoc_syntax_filetypes = {
  \ "sql" : {
  \   "start" : "SQL",
  \},
  \ "xml" : {
  \   "start" : "XML",
  \},
\}

" Yes, test for > 1, not > 0. There's no use in jumping to line 1,
" if Vim would start at line 1 anyway.
if has('nvim')
  autocmd BufReadPost *
    \  if line("'\"") > 1 && line("'\"") <= line("$")
    \|   exe 'normal! g`"zvzz'
    \| endif
endif

if v:version < '800'
  let g:syntastic_ruby_checkers = ['rubocop']
  let g:syntastic_eruby_checkers = ['ruumba']
  set statusline+=%#warningmsg#
  set statusline+=%{SyntasticStatuslineFlag()}
  set statusline+=%*

  let g:syntastic_always_populate_loc_list = 1
  let g:syntastic_auto_loc_list = 0
  let g:syntastic_check_on_open = 1
  let g:syntastic_check_on_wq = 0
else
  let g:ale_linters = { 'ruby': ['rubocop'], 'eruby': ['ruumba'] }
  let g:ale_lint_on_text_changed = 'normal'
  let g:ale_lint_on_enter = 0

  let g:airline#extensions#ale#enabled = 1

  let g:EclimJavaValidate = 0

  autocmd FileType java let g:ale_java_javac_classpath=eclim#Execute('-command java_classpath -p ' . eclim#project#util#GetCurrentProjectName())
endif

let g:localvimrc_persistent = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = 'unique_tail'

set spelllang=en_gb,de
autocmd FileType mail set spell
autocmd FileType gitcommit set spell

autocmd BufEnter,BufNew *.info call CheckSlackBuildInfo()
function CheckSlackBuildInfo()
  if filereadable(expand('%:p:r'). '.SlackBuild')
    setlocal filetype=sh
  endif
endfunction

if has('nvim')
  let $FZF_DEFAULT_OPTS .= ' --inline-info'
endif

" Hide statusline of terminal buffer
autocmd! FileType fzf
autocmd  FileType fzf set laststatus=0 noshowmode noruler
  \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

" Customize fzf colors to match your color scheme
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

command! -bang -nargs=? -complete=dir Files
  \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)

command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   'rg -M120 --column --line-number --no-heading --color=always --smart-case '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview('up:60%')
  \           : fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)

command! -bang -nargs=* Ag
  \ call fzf#vim#ag(<q-args>,
  \                 <bang>0 ? fzf#vim#with_preview('up:60%')
  \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
  \                 <bang>0)

" some mappings for fzf commands
nnoremap <Space>pf :Files<ENTER>
nnoremap <Space>srp :Rg<ENTER>
nnoremap <Space>sap :Ag<ENTER>
nnoremap <Space>bb :Buffers<ENTER>
nnoremap <Space>* :Rg <C-R><C-W><ENTER>

" Bubble single lines
nmap <C-Up> [e
nmap <C-Down> ]e
" Bubble multiple lines
vmap <C-Up> [egv
vmap <C-Down> ]egv

augroup vimrc
  au BufNewFile,BufRead Jenkinsfile*         set filetype=groovy
augroup END

" some more mappings
nnoremap <Space>bd :bd<ENTER>
nnoremap <Space>bn :bn<ENTER>
nnoremap <Space>bp :bp<ENTER>
nnoremap <Space>gb :Gblame<ENTER>

nnoremap <Space>el :lopen<ENTER>
nnoremap <Space>eL :lclose<ENTER>
